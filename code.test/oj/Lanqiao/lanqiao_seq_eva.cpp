/*************************************************************************
	> File Name: lanqiao_seq_eva.cpp
	> Author: sunowsir
	> GitHub: github.com/sunowsir
	> Created Time: 2018年03月28日 星期三 21时57分56秒
 ************************************************************************/

#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;

int main() {

    int n;
    double A0, An1, ans;
    double A[1010], C[1010];
    memset(A, 0, sizeof(A));
    memset(C, 0, sizeof(C));

    cin >> n >> A0 >> An1;

    A[0] = A0;
    A[1] = 0;

    for(int i = 1; i <= n; i++) {
        
        cin >> C[i];
        A[i + 1] = 2.0 * A[i] + (2.0 * C[i] - A[i - 1]);//括号里的一堆就是下面讲解李被当做一个常量处理的Xi+1；
    
    }

    ans = (An1 - A[n + 1]) / (n + 1.0);

    printf("%.2lf\n", ans);

    return 0; 
}

/*
 * 本题给出了下面的式子，输入A0、An+1、n还有C1到Cn n个数，要我们求出A1;
 * Ai = (Ai-1 + Ai+1) / 2 - Ci;
 * 上式变形：Ai+1 = 2 * Ai + (2 * Ci + - Ai-1);
 * A2 = 2 * A1 + (2 * C1 - A0);//括号里的所有直接看成一个常量X2;
 * A3 = 2 * A2 + (2 * c2 - A1);//把这一行的A2用上一行代替；
 * 得：A3 = 3 * A1 + (4 * C1 + 2 * C2 - 2 * A0);//同样，不管括号里面有什么，都把它看成一个常量X3;
 * .
 * .
 * .
 * An+1 = (n + 1) * A1 + Xn+1;//直接把括号里的一堆看成常量Xn+1;
 * 这样推导为了变成从A2到An+1都等于下角标倍数的A1再加上一堆常量的形式；
 * 我们看上上行的式子，我们能看出来，只要求出Xn+1就能求出A1了；
 * 我们设A1 = 0；
 * 那么上面的一系列推导的式子就变成了：
 * A2 = 0 + X2;
 * A3 = 0 + X3;
 * .
 * .
 * .
 * An+1 = 0 + Xn+1;
 * 也就是说，当A1 = 0的时候，求出的An+1就是Xn+1;
 * 只要我们在输入C1到Cn的同时利用上面最开始21行变形得来的式子就能求出当A1 = 0的时候An+1的值，也就是Xn+1;
 * 再带入28行（这里是41行）就能求出 A1了；
 */

